"use strict";(self.webpackChunkxtd=self.webpackChunkxtd||[]).push([[5667],{91971:(e,t,a)=>{a.d(t,{Zo:()=>u,kt:()=>_});var n=a(76687);function s(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){s(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function r(e,t){if(null==e)return{};var a,n,s=function(e,t){if(null==e)return{};var a,n,s={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(s[a]=e[a]);return s}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(s[a]=e[a])}return s}var o=n.createContext({}),c=function(e){var t=n.useContext(o),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},u=function(e){var t=c(e.components);return n.createElement(o.Provider,{value:t},e.children)},m="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var a=e.components,s=e.mdxType,i=e.originalType,o=e.parentName,u=r(e,["components","mdxType","originalType","parentName"]),m=c(a),d=s,_=m["".concat(o,".").concat(d)]||m[d]||p[d]||i;return a?n.createElement(_,l(l({ref:t},u),{},{components:a})):n.createElement(_,l({ref:t},u))}));function _(e,t){var a=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var i=a.length,l=new Array(i);l[0]=d;var r={};for(var o in t)hasOwnProperty.call(t,o)&&(r[o]=t[o]);r.originalType=e,r[m]="string"==typeof e?e:s,l[1]=r;for(var c=2;c<i;c++)l[c]=a[c];return n.createElement.apply(null,l)}return n.createElement.apply(null,a)}d.displayName="MDXCreateElement"},99590:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>o,contentTitle:()=>l,default:()=>p,frontMatter:()=>i,metadata:()=>r,toc:()=>c});var n=a(855),s=(a(76687),a(91971));const i={sidebar_position:14},l="Writing test applications",r={unversionedId:"documentation/Guides/Overview/Tutorials/writing_applicaion_test",id:"documentation/Guides/Overview/Tutorials/writing_applicaion_test",title:"Writing test applications",description:"In This Section",source:"@site/docs/documentation/Guides/Overview/Tutorials/writing_applicaion_test.md",sourceDirName:"documentation/Guides/Overview/Tutorials",slug:"/documentation/Guides/Overview/Tutorials/writing_applicaion_test",permalink:"/xtd/docs/documentation/Guides/Overview/Tutorials/writing_applicaion_test",draft:!1,tags:[],version:"current",sidebarPosition:14,frontMatter:{sidebar_position:14},sidebar:"tutorialSidebar",previous:{title:"Writing GUI application",permalink:"/xtd/docs/documentation/Guides/Overview/Tutorials/writing_applicaion_gui"},next:{title:"Some useful git commands",permalink:"/xtd/docs/documentation/Guides/Overview/Tutorials/git"}},o={},c=[{value:"In This Section",id:"in-this-section",level:2},{value:"Namespace",id:"namespace",level:2},{value:"Helpers",id:"helpers",level:2},{value:"Examples",id:"examples",level:3},{value:"More helpers",id:"more-helpers",level:3},{value:"Remarks",id:"remarks",level:4},{value:"Assertions",id:"assertions",level:2},{value:"Example",id:"example",level:3},{value:"Validations",id:"validations",level:2},{value:"Example",id:"example-1",level:3},{value:"Assumptions",id:"assumptions",level:2},{value:"Example",id:"example-2",level:3},{value:"Initialize and Cleanup",id:"initialize-and-cleanup",level:2},{value:"Test case",id:"test-case",level:2},{value:"Test class",id:"test-class",level:2},{value:"Test",id:"test",level:2},{value:"See also",id:"see-also",level:2}],u={toc:c},m="wrapper";function p(e){let{components:t,...a}=e;return(0,s.kt)(m,(0,n.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"writing-test-applications"},"Writing test applications"),(0,s.kt)("h2",{id:"in-this-section"},"In This Section"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"#namespace"},"Namespace")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"#helpers"},"Helpers")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"#assertions"},"Assertions")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"#validations"},"Validations")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"#assumptions"},"Assumptions")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"#initialize-and-cleanup"},"Initialize and Cleanup")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"#test-case"},"Test case")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"#test-class"},"Test class")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"#test"},"Test"))),(0,s.kt)("h2",{id:"namespace"},"Namespace"),(0,s.kt)("p",null,"xtd.tunit has a unique namespace : ",(0,s.kt)("strong",{parentName:"p"},(0,s.kt)("em",{parentName:"strong"},"xtd::tunit")),"."),(0,s.kt)("p",null,"This example show how to use xtd.tunit with using namespace:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cpp"},"#include <xtd/tunit>\n\nusing namespace xtd::tunit;\n\nnamespace unit_tests {\n  class test_class_(test) {\n  public:\n    // Test case 1\n    void test_method_(test_case1) {\n      assert::is_true(2 + 2 == 4);\n    }\n  };\n}\n\n\nauto main()->int {\n  return console_unit_test().run();\n}\n")),(0,s.kt)("p",null,"This example show how to use xtd.tunit without using namespace:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cpp"},"#include <xtd/tunit>\n\nnamespace unit_tests {\n  class test_class_(test) {\n  public:\n    // Test case 1\n    void test_method_(test_case1) {\n      xtd::tunit::assert::is_true(2 + 2 == 4);\n    }\n  };\n}\n\n\nauto main()->int {\n  return xtd::tunit::console_unit_test().run();\n}\n")),(0,s.kt)("h2",{id:"helpers"},"Helpers"),(0,s.kt)("p",null,"xtd.tunit uses custom helpers to identify test fixtures and test methods. It's the easy way to create tests."),(0,s.kt)("table",null,(0,s.kt)("thead",{parentName:"table"},(0,s.kt)("tr",{parentName:"thead"},(0,s.kt)("th",{parentName:"tr",align:null},"helpers"),(0,s.kt)("th",{parentName:"tr",align:null},"Usage"))),(0,s.kt)("tbody",{parentName:"table"},(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("a",{parentName:"td",href:"/docs/documentation/Guides/Overview/Tutorials/test_class"},"test",(0,s.kt)("em",{parentName:"a"},"class"),"(class_name)")),(0,s.kt)("td",{parentName:"tr",align:null},"Is used to define the class (test fixture) with class_name name.")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("a",{parentName:"td",href:"/docs/documentation/Guides/Overview/Tutorials/class_initialize"},"class",(0,s.kt)("em",{parentName:"a"},"initialize"),"(initialize_name)")),(0,s.kt)("td",{parentName:"tr",align:null},"Is used to define class initialize method with initialize_name name.")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("a",{parentName:"td",href:"/docs/documentation/Guides/Overview/Tutorials/class_cleanup"},"class",(0,s.kt)("em",{parentName:"a"},"cleanup"),"(cleanup_name)")),(0,s.kt)("td",{parentName:"tr",align:null},"Is used to define class cleanup method with cleanup_name name.")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("a",{parentName:"td",href:"/docs/documentation/Guides/Overview/Tutorials/test_initialize"},"test",(0,s.kt)("em",{parentName:"a"},"initialize"),"(initialize_name)")),(0,s.kt)("td",{parentName:"tr",align:null},"Is used to define test initialize method with initialize_name name.")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("a",{parentName:"td",href:"/docs/documentation/Guides/Overview/Tutorials/test_cleanup"},"test",(0,s.kt)("em",{parentName:"a"},"cleanup"),"(cleanup_name)")),(0,s.kt)("td",{parentName:"tr",align:null},"Is used to define test cleanup method with cleanup_name name.")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("a",{parentName:"td",href:"/docs/documentation/Guides/Overview/Tutorials/test_method"},"test",(0,s.kt)("em",{parentName:"a"},"method"),"(method_name)")),(0,s.kt)("td",{parentName:"tr",align:null},"Is used to define test method (test case) with method_name name.")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("a",{parentName:"td",href:"/docs/documentation/Guides/Overview/Tutorials/ingore_test_method"},"ignore",(0,s.kt)("em",{parentName:"a"},"test_method"),"(method_name)")),(0,s.kt)("td",{parentName:"tr",align:null},"Is used to define ignored test method (test case) with method_name name.")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("a",{parentName:"td",href:"/docs/documentation/Guides/Overview/Tutorials/csf"},"csf_")),(0,s.kt)("td",{parentName:"tr",align:null},"Is used to create a xtd::diagnostics::stack_frame class initialized with current method name, current file name and current line number.")))),(0,s.kt)("h3",{id:"examples"},"Examples"),(0,s.kt)("p",null,"The following example shows how to create and register fixture and test cases with helpers :"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cpp"},"#include <xtd/tunit>\n\nusing namespace xtd::tunit;\n\nnamespace unit_tests {\n  // Create new test fixture with test_class_ helper.\n  class test_class_(test) {\n  public:\n    // This method is called 1 time before test class run\n    static void class_initialize_(class_initialize) {\n    }\n    \n    // This method is called 1 time after test class run\n    static void class_cleanup_(class_cleanup) {\n    }\n    \n    // This method that is called before each test case of test fixture.\n    static void test_initialize_(test_initialize) {\n    }\n    \n    // This method is called after each test case of test fixture.\n    static void test_cleanup_(test_cleanup) {\n    }\n    \n    // Test case 1\n    void test_method_(test_case1) {\n    }\n    \n    // Test case 2\n    void test_method_(test_case2) {\n    }\n    \n    // Ignore Test case 3\n    void ignore_test_method_(test_case3) {\n    }\n  };\n}\n\nauto main(int argc, char* argv[])->int {\n  return console_unit_test(argv, argc).run();\n}\n")),(0,s.kt)("p",null,"The following example shows how to create and register same fixture and same test cases without helpers :"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <xtd/tunit>\n\nusing namespace xtd::tunit;\n\nnamespace unit_tests {\n  // Used test_class_attribute<> to register test fixture.\n  class test;\n  test_class_attribute<test> test_class_attr {"test"};\n\n  // Create new test fixture inherited test_class.\n  class test : public test_class {\n  public:\n    // Used class_initialize_attribute object to register class initialize method.\n    class_initialize_attribute class_initialize_attr {"class_initialize", *this, &test::class_initialize};\n    \n    // This method is called 1 time before test class run.\n    static void class_initialize() {\n    }\n\n    // Used class_cleanup_attribute object to register class cleanup method.\n    class_cleanup_attribute class_cleanup_attr {"class_cleanup", *this, &test::class_cleanup};\n\n    // This method is called 1 time after test class run.\n    static void class_cleanup() {\n    }\n\n    // Used test_initialize_attribute object to register test initialize method.\n    test_initialize_attribute test_initialize_attr {"test_initialize", *this, &test::test_initialize};\n    \n    // This method is called before each test case of test fixture.\n    static void test_initialize() {\n    }\n\n    // Used test_cleanup_attribute object to register test cleanup method.\n    test_cleanup_attribute test_cleanup_attr {"test_cleanup", *this, &test::test_cleanup};\n   \n    // This method that is called after each test case of test fixture.\n    static void test_cleanup() {\n    }\n\n    // Used test_method_attribute object to register test case 1 method.\n    test_method_attribute test_case1_attr {"test_case1", *this, &test::test_case1};\n    \n    // Test case 1\n    void test_case1() {\n    }\n\n    // Used test_method_attribute object to register test case 2 method.\n    test_method_attribute test_case2_attr {"test_case2", *this, &test::test_case2};\n    \n    // Test case 2\n    void test_case2() {\n    }\n\n    // Used test_method_attribute object to register and ignore test case 3 method.\n    test_method_attribute test_case3_attr {"test_case3", *this, &test::test_case3, test_state::ignored};\n    \n    // Ignore Test case 3\n    void test_case3() {\n  };\n}\n\nauto main(int argc, char* argv[])->int {\n  return console_unit_test(argv, argc).run();\n}\n')),(0,s.kt)("p",null,"The following example shows how to get current informations with helper :"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <xtd/tunit>\n#include <iostream>\n\nusing namespace std;\nusing namespace xtd::tunit;\n\nvoid trace_message(const string& message, const xtd::diagnostics::stack_frame& stack_frame) {\n  cout << "message: " << message << endl;\n  cout << "member name: " << stack_frame.get_method() << endl;\n  cout << "source file path: " << stack_frame.get_file_name() << endl;\n  cout << "source line number: " << stack_frame.get_file_line_number() << endl;\n}\n\nauto main()->int {\n  trace_message("Something happened.", csf_);\n}\n')),(0,s.kt)("p",null,"The following example shows how to get same current informations without helper :"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <xtd/tunit>\n#include <iostream>\n\nusing namespace std;\nusing namespace xtd::tunit;\n\nvoid trace_message(const string& message, const xtd::diagnostics::stack_frame& stack_frame) {\n  cout << "message: " << message << endl;\n  cout << "member name: " << stack_frame.get_method() << endl;\n  cout << "source file path: " << stack_frame.get_file_name() << endl;\n  cout << "source line number: " << stack_frame.get_file_line_number() << endl;\n}\n\nauto main()->int {\n  trace_message("Something happened.", xtd::diagnostics::stack_frame(__FILE__, __LINE__, __func__));\n}\n')),(0,s.kt)("h3",{id:"more-helpers"},"More helpers"),(0,s.kt)("p",null,"For each assertion, validation or assumption test method, the last parameter is xtd::diagnostics::stack",(0,s.kt)("em",{parentName:"p"},"frame class that contains current informations.\nTo add automatically xtd::diagnostics::stack_frame, helpers are create. Add '"),"' at the end of test method member to used helper."),(0,s.kt)("p",null,"example without helper :"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cpp"},"assert::contains('a', str, csf_);\nstring_valid::are_equal_ignoring_case(\"value\", str, csf_);\n")),(0,s.kt)("p",null,"example with helper :"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cpp"},"assert::contains_('a', str);\nstring_valid::are_equal_ignoring_case_(\"value\", str);\n")),(0,s.kt)("p",null,"The following example shows hot to call are_equal assertion tests with helper :"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <xtd/tunit>\n\nusing namespace xtd::tunit;\n\nnamespace unit_tests {\n  class test_class_(test) {\n  public:\n    void test_method_(test_case_1) {\n      int i = 24;\n      assert::are_equal_(24, i);\n      assert::are_equal_(24, i, "My message");\n    }\n  };\n}\n\nauto main(int argc, char* argv[])->int {\n  return console_unit_test(argv, argc).run();\n}\n')),(0,s.kt)("p",null,"The following example shows hot to call the same are_equal assertion tests without helper :"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <xtd/tunit>\n\nusing namespace xtd::tunit;\n\nnamespace unit_tests {\n  class test_class_(test) {\n  public:\n    void test_method_(test_case_1) {\n      int i = 24;\n      assert::are_equal(24, i, xtd::diagnostics::stack_frame(__FILE__, __LINE__, __func__));\n      assert::are_equal(24, i, "My message", xtd::diagnostics::stack_frame(__FILE__, __LINE__, _-func__));\n    }\n  };\n}\n\nauto main(int argc, char* argv[])->int {\n  return console_unit_test(argv, argc).run();\n}\n')),(0,s.kt)("h4",{id:"remarks"},"Remarks"),(0,s.kt)("p",null,"Some functions are template, in this case the template parameter becomes the first parameter of the helper."),(0,s.kt)("p",null,"example without helper : "),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cpp"},"assert::is_instance_of<std::ios_base>(stream, csf_);\n")),(0,s.kt)("p",null,"example with helper :"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cpp"},"assert::is_instance_of_(std::ios_base, stream);\n")),(0,s.kt)("h2",{id:"assertions"},"Assertions"),(0,s.kt)("p",null,"Assertions are central to unit testing in any of the xUnit frameworks, and xtd.tunit is no exception. xtd.tunit provides a rich set of assertions as static methods of the Assert class."),(0,s.kt)("p",null,"If an assertion fails, the method call does not return and an error is reported. If a test contains multiple assertions, any that follow the one that failed will not be executed. For this reason, it's usually best to try for one assertion per test."),(0,s.kt)("p",null,"Each method may be called without a message, with a simple text message or with a message and arguments. In the last case the message is formatted using the provided text and arguments."),(0,s.kt)("p",null,"Assertions make use with the following static classes :"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"assert"),(0,s.kt)("li",{parentName:"ul"},"string_assert"),(0,s.kt)("li",{parentName:"ul"},"collection_assert"),(0,s.kt)("li",{parentName:"ul"},"file_assert"),(0,s.kt)("li",{parentName:"ul"},"directory_assert.")),(0,s.kt)("h3",{id:"example"},"Example"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cpp"},'void test_method_(test_case_1) {\n  assert::are_equal(4, 2 + 2, csf_);\n  string_Assert::start_width("Hello", "Hello, World!", csf_)\n}\n')),(0,s.kt)("h2",{id:"validations"},"Validations"),(0,s.kt)("p",null,"Validations are the same as assertions with the difference, no exception is thrown, but an error is generated. "),(0,s.kt)("p",null,"If a validation fails, he test can be continued to the end or to an assertion is generated."),(0,s.kt)("p",null,"Validations make use with the following static classes :"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"valid"),(0,s.kt)("li",{parentName:"ul"},"string_valid"),(0,s.kt)("li",{parentName:"ul"},"collection_valid"),(0,s.kt)("li",{parentName:"ul"},"file_valid"),(0,s.kt)("li",{parentName:"ul"},"directory_valid.")),(0,s.kt)("h3",{id:"example-1"},"Example"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cpp"},'void test_method_(test_case_1) {\n  valid::are_equal(4, 2 + 2, csf_);\n  string_valid::start_width("Hello", "Hello, World!", csf_)\n}\n')),(0,s.kt)("h2",{id:"assumptions"},"Assumptions"),(0,s.kt)("p",null,"Assumptions are intended to express the state a test must be in to provide a meaningful result. They are functionally similar to assertions, however a unmet assumption will produce an aborted test result, as opposed to a failure."),(0,s.kt)("p",null,"Assumptions make use with the following static classes :"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"assume"),(0,s.kt)("li",{parentName:"ul"},"string_assume"),(0,s.kt)("li",{parentName:"ul"},"collection_assume"),(0,s.kt)("li",{parentName:"ul"},"file_assume"),(0,s.kt)("li",{parentName:"ul"},"directory_assume.")),(0,s.kt)("h3",{id:"example-2"},"Example"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cpp"},'void test_method_(test_case_1) {\n  assume::are_equal(4, 2 + 2, csf_);\n  string_assume::start_width("Hello", "Hello, World!", csf_)\n}\n')),(0,s.kt)("h2",{id:"initialize-and-cleanup"},"Initialize and Cleanup"),(0,s.kt)("p",null,"Coming soon..."),(0,s.kt)("h2",{id:"test-case"},"Test case"),(0,s.kt)("p",null,"Coming soon..."),(0,s.kt)("h2",{id:"test-class"},"Test class"),(0,s.kt)("p",null,"Coming soon..."),(0,s.kt)("h2",{id:"test"},"Test"),(0,s.kt)("p",null,"Coming soon..."),(0,s.kt)("h2",{id:"see-also"},"See also"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"/docs/documentation/Guides/Overview/Tutorials"},"tutorials")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"/docs/documentation"},"Documentation"))))}p.isMDXComponent=!0}}]);