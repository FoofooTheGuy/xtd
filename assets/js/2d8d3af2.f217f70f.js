"use strict";(self.webpackChunkxtd=self.webpackChunkxtd||[]).push([[8673],{91971:(e,t,a)=>{a.d(t,{Zo:()=>c,kt:()=>u});var n=a(76687);function o(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function l(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?l(Object(a),!0).forEach((function(t){o(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function r(e,t){if(null==e)return{};var a,n,o=function(e,t){if(null==e)return{};var a,n,o={},l=Object.keys(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||(o[a]=e[a]);return o}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(o[a]=e[a])}return o}var d=n.createContext({}),i=function(e){var t=n.useContext(d),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},c=function(e){var t=i(e.components);return n.createElement(d.Provider,{value:t},e.children)},m="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},p=n.forwardRef((function(e,t){var a=e.components,o=e.mdxType,l=e.originalType,d=e.parentName,c=r(e,["components","mdxType","originalType","parentName"]),m=i(a),p=o,u=m["".concat(d,".").concat(p)]||m[p]||h[p]||l;return a?n.createElement(u,s(s({ref:t},c),{},{components:a})):n.createElement(u,s({ref:t},c))}));function u(e,t){var a=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var l=a.length,s=new Array(l);s[0]=p;var r={};for(var d in t)hasOwnProperty.call(t,d)&&(r[d]=t[d]);r.originalType=e,r[m]="string"==typeof e?e:o,s[1]=r;for(var i=2;i<l;i++)s[i]=a[i];return n.createElement.apply(null,s)}return n.createElement.apply(null,a)}p.displayName="MDXCreateElement"},79532:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>d,contentTitle:()=>s,default:()=>h,frontMatter:()=>l,metadata:()=>r,toc:()=>i});var n=a(855),o=(a(76687),a(91971));const l={},s="Delegates",r={unversionedId:"documentation/Guides/xtd.core/Types overview/delegates",id:"documentation/Guides/xtd.core/Types overview/delegates",title:"Delegates",description:"In This Section",source:"@site/docs/documentation/Guides/xtd.core/Types overview/delegates.md",sourceDirName:"documentation/Guides/xtd.core/Types overview",slug:"/documentation/Guides/xtd.core/Types overview/delegates",permalink:"/xtd/docs/documentation/Guides/xtd.core/Types overview/delegates",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Date and time",permalink:"/xtd/docs/documentation/Guides/xtd.core/Types overview/date_time"},next:{title:"enum, enum class and enum struct",permalink:"/xtd/docs/documentation/Guides/xtd.core/Types overview/enum_class"}},d={},i=[{value:"In This Section",id:"in-this-section",level:2},{value:"Overview",id:"overview",level:2},{value:"Notes",id:"notes",level:3},{value:"Difference betwwen xtd::delegate and std::function",id:"difference-betwwen-xtddelegate-and-stdfunction",level:2},{value:"Delegates Overview",id:"delegates-overview",level:2},{value:"Using Delegates",id:"using-delegates",level:2},{value:"Delegates with Named methods",id:"delegates-with-named-methods",level:2},{value:"Remarks",id:"remarks",level:3},{value:"Example 1",id:"example-1",level:3},{value:"Example 2",id:"example-2",level:3},{value:"Delegates with Lambda expressions",id:"delegates-with-lambda-expressions",level:2},{value:"See also",id:"see-also",level:2}],c={toc:i},m="wrapper";function h(e){let{components:t,...a}=e;return(0,o.kt)(m,(0,n.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"delegates"},"Delegates"),(0,o.kt)("h2",{id:"in-this-section"},"In This Section"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#overview"},"Overview")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#difference-betwwen-xtddelegate-and-stdfunction"},"Difference betwwen xtd::delegate and std::function")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#delegates-overview"},"Delegates Overview")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#using-delegates"},"Using Delegates")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#delegates-with-named-methods"},"Delegates with Named methods")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#delegates-with-lambda-expressions"},"Delegates with Lambda expressions"))),(0,o.kt)("h2",{id:"overview"},"Overview"),(0,o.kt)("p",null,"A ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/gammasoft71/xtd/blob/master/src/xtd.core/include/xtd/delegate.h"},"xtd::delegate")," is a type that represents references to methods with a particular parameter list and return type. When you instantiate a delegate, you can associate its instance with any method with a compatible signature and return type. You can invoke (or call) the method through the delegate instance."),(0,o.kt)("p",null,"Delegates are used to pass methods as arguments to other methods. Event handlers are nothing more than methods that are invoked through delegates. You create a custom method, and a class such as a windows control can call your method when a certain event occurs. The following example shows a delegate declaration:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"using perform_calculation = xtd::delegate<int(int x, int y)>;\n")),(0,o.kt)("p",null,"Any method from any accessible class or struct that matches the delegate type can be assigned to the delegate. The method can be either static or an instance method. This flexibility means you can programmatically change method calls, or plug new code into existing classes."),(0,o.kt)("h3",{id:"notes"},"Notes"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"In the context of method overloading, the signature of a method does not include the return value. But in the context of delegates, the signature does include the return value. In other words, a method must have the same return type as the delegate.")),(0,o.kt)("p",null,"This ability to refer to a method as a parameter makes delegates ideal for defining callback methods. You can write a method that compares two objects in your application. That method can be used in a delegate for a sort algorithm. Because the comparison code is separate from the library, the sort method can be more general."),(0,o.kt)("h2",{id:"difference-betwwen-xtddelegate-and-stdfunction"},"Difference betwwen xtd::delegate and std::function"),(0,o.kt)("p",null,"Unlike std::function, xtd::delegate can be chained together; for example, multiple methods can be called on a single event."),(0,o.kt)("p",null,"A xtd::delegate is a collection of std::function."),(0,o.kt)("h2",{id:"delegates-overview"},"Delegates Overview"),(0,o.kt)("p",null,"Delegates have the following properties:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Delegates are similar to C++ function pointers, but delegates like std::function are fully object-oriented, and unlike C++ pointers to member functions, delegates encapsulate both an object instance and a method."),(0,o.kt)("li",{parentName:"ul"},"Delegates allow methods to be passed as parameters."),(0,o.kt)("li",{parentName:"ul"},"Delegates can be used to define callback methods."),(0,o.kt)("li",{parentName:"ul"},"Unlike std::function, delegates can be chained together; for example, multiple methods can be called on a single event."),(0,o.kt)("li",{parentName:"ul"},"Lambda expressions are a more concise way of writing inline code blocks. Lambda expressions (in certain contexts) are compiled to delegate types. For more information about lambda expressions, see ",(0,o.kt)("a",{parentName:"li",href:"https://en.cppreference.com/w/cpp/language/lambda"},"Lambda expressions"),".")),(0,o.kt)("h2",{id:"using-delegates"},"Using Delegates"),(0,o.kt)("p",null,"A ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/gammasoft71/xtd/blob/master/src/xtd.core/include/xtd/delegate.h"},"xtd::delegate")," is a type that safely encapsulates a method, similar to a function pointer in C and C++. Unlike C function pointers, delegates are object-oriented, type safe, and secure. The type of a delegate is defined by the name of the delegate. The following example declares a delegate named ",(0,o.kt)("strong",{parentName:"p"},"del")," that can encapsulate a method that takes a ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/gammasoft71/xtd/blob/master/src/xtd.core/include/xtd/ustring.h"},"xtd::ustring")," as an argument and returns void:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"using del = xtd::delegate<void(const xtd::ustring& message)>;\n")),(0,o.kt)("p",null,"A delegate object is normally constructed by providing the name of the method the delegate will wrap, or with a lambda expression. Once a delegate is instantiated, a method call made to the delegate will be passed by the delegate to that method. The parameters passed to the delegate by the caller are passed to the method, and the return value, if any, from the method is returned to the caller by the delegate. This is known as invoking the delegate. An instantiated delegate can be invoked as if it were the wrapped method itself. For example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"// Create a method for a delegate.\nvoid delegate_method(const xtd::ustring& message) {\n  console::write_line(message);\n}\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},'// Instantiate the delegate.\ndel handler = {delegate_method};\n\n// Call the delegate.\nhandler("Hello World");\n')),(0,o.kt)("p",null,"or"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},'// Instantiate the delegate.\ndel handler = del(delegate_method);\n\n// Call the delegate.\nhandler("Hello World");\n')),(0,o.kt)("p",null,"Because the instantiated ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/gammasoft71/xtd/blob/master/src/xtd.core/include/xtd/delegate.h"},"xtd::delegate")," is an object, it can be passed as a parameter, or assigned to a property. This allows a method to accept a delegate as a parameter, and call the delegate at some later time. This is known as an asynchronous callback, and is a common method of notifying a caller when a long process has completed. When a delegate is used in this fashion, the code using the delegate does not need any knowledge of the implementation of the method being used. The functionality is similar to the encapsulation interfaces provide."),(0,o.kt)("p",null,"Another common use of callbacks is defining a custom comparison method and passing that delegate to a sort method. It allows the caller's code to become part of the sort algorithm. The following example method uses the ",(0,o.kt)("strong",{parentName:"p"},"del")," type as a parameter:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},'void method_with_callback(int param1, int param2, del callback) {\n  callback("The number is: " +  to_string(param1 + param2));\n}\n')),(0,o.kt)("p",null,"You can then pass the delegate created above to that method:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"method_with_callback(1, 2, handler);\n")),(0,o.kt)("p",null,"and receive the following output to the console:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"The number is: 3\n")),(0,o.kt)("p",null,"Using the delegate as an abstraction, ",(0,o.kt)("strong",{parentName:"p"},"method_with_callback")," does not need to call the console directly\u2014it does not have to be designed with a console in mind. What ",(0,o.kt)("strong",{parentName:"p"},"method_with_callback")," does is simply prepare a string and pass the string to another method. This is especially powerful since a delegated method can use any number of parameters.\nWhen a ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/gammasoft71/xtd/blob/master/src/xtd.core/include/xtd/delegate.h"},"xtd::delegate")," is constructed to wrap an instance method, the delegate references both the instance and the method. A delegate has no knowledge of the instance type aside from the method it wraps, so a delegate can refer to any type of object as long as there is a method on that object that matches the delegate signature. When a delegate is constructed to wrap a static method, it only references the method. Consider the following declarations:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"class method_class {\npublic:\n    void method1(const xtd::ustring& message) { }\n    void method2(const xtd::ustring& message) { }\n}\n")),(0,o.kt)("p",null,"Along with the static ",(0,o.kt)("strong",{parentName:"p"},"delegate_method")," shown previously, we now have three methods that can be wrapped by a ",(0,o.kt)("strong",{parentName:"p"},"del")," instance."),(0,o.kt)("p",null,"A delegate can call more than one method when invoked. This is referred to as multicasting. To add an extra method to the delegate's list of methods\u2014the invocation list\u2014simply requires adding two delegates using the addition or addition assignment operators ('+' or '+='). For example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"method_class obj;\ndel d1 = {obj, &method_class::method1};\ndel d2 = {obj, &method_class::method2};\ndel d3 = {delegate_method};\n\n//Both types of assignment are valid.\ndel all_methods_delegate = d1 + d2;\nall_methods_delegate += d3;\n")),(0,o.kt)("p",null,"At this point ",(0,o.kt)("strong",{parentName:"p"},"all_methods_delegate")," contains three methods in its invocation list\u2014",(0,o.kt)("strong",{parentName:"p"},"method1"),", ",(0,o.kt)("strong",{parentName:"p"},"method2"),", and ",(0,o.kt)("strong",{parentName:"p"},"delegate_method"),".\nThe original three delegates, ",(0,o.kt)("strong",{parentName:"p"},"d1"),", ",(0,o.kt)("strong",{parentName:"p"},"d2"),", and ",(0,o.kt)("strong",{parentName:"p"},"d3"),", remain unchanged. When ",(0,o.kt)("strong",{parentName:"p"},"all_methods_delegate")," is invoked, all three methods are called in order. If the delegate uses reference parameters, the reference is passed sequentially to each of the three methods in turn, and any changes by one method are visible to the next method. When any of the methods throws an exception that is not caught within the method, that exception is passed to the caller of the delegate and no subsequent methods in the invocation list are called. If the delegate has a return value and/or out parameters, it returns the return value and parameters of the last method invoked.\nTo remove a method from the invocation list, use the subtraction or subtraction assignment operators (- or -=). For example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"//remove Method1\nall_methods_delegate -= d1;\n\n// copy all_methods_delegate while removing d2\ndel one_method_delegate = all_methods_delegate - d2;\n")),(0,o.kt)("p",null,"Because ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/gammasoft71/xtd/blob/master/src/xtd.core/include/xtd/delegate.h"},"xtd::delegate")," types is a class, the methods and properties defined by that class can be called on the delegate.\nFor example, to find the number of methods in a delegate's invocation list, you may write:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"size_t invocation_count = d1.size();\n")),(0,o.kt)("p",null,"Multicast delegates are used extensively in event handling. ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/gammasoft71/xtd/blob/master/src/xtd.core/include/xtd/event.h"},"xtd::event")," source objects send event notifications to recipient objects that have registered to receive that event. To register for an event, the recipient creates a method designed to handle the event, then creates a delegate for that method and passes the delegate to the event source. The source calls the delegate when the event occurs. The delegate then calls the event handling method on the recipient, delivering the event data. The delegate type for a given event is defined by the event source. For more, see ",(0,o.kt)("a",{parentName:"p",href:"/docs/documentation/Guides/xtd.core/Types%20overview/events"},"events"),"."),(0,o.kt)("p",null,"Comparing delegates of two different types assigned at compile-time will result in a compilation error. If the delegate instances are statically of the type ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/gammasoft71/xtd/blob/master/src/xtd.core/include/xtd/delegate.h"},"xtd::delegate"),", then the comparison is allowed, but will return false at run time. For example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"template<typename result_t, typename... arguments_t>\nvoid method(delegate1 d, delegate2 e, xtd::delegate<result_t(arguments_t...)> f) {\n  // Compile-time error.\n  //console::write_line(d == e);\n  \n  // OK at compile-time. False if the run-time type of f\n  // is not the same as that of d.\n  console::write_line(d == f);\n}\n")),(0,o.kt)("h2",{id:"delegates-with-named-methods"},"Delegates with Named methods"),(0,o.kt)("p",null,"A ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/gammasoft71/xtd/blob/master/src/xtd.core/include/xtd/delegate.h"},"xtd::delegate")," can be associated with a named method. When you instantiate a delegate by using a named method, the method is passed as a parameter, for example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"// Declare a delegate.\nusing del = xtd::delegate<void(int x)>;\n\n// Define a named method.\nvoid doW_work(int k) { /* ... */ }\n\n// Instantiate the delegate using the method as a parameter.\ndel d = {obj, &objectt_class::do_work};\n")),(0,o.kt)("p",null,"This is called using a named method. Delegates constructed with a named method can encapsulate either a static method or an instance method. However, in a situation where creating a new method is unwanted overhead, C++ and xtd enable you to instantiate a delegate and immediately specify a code block that the delegate will process when it is called. The block can contain either a ",(0,o.kt)("a",{parentName:"p",href:"#lambda-expression"},"lambda expression"),"."),(0,o.kt)("h3",{id:"remarks"},"Remarks"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"The method that you pass as a delegate parameter must have the same signature as the delegate declaration."),(0,o.kt)("li",{parentName:"ul"},"A delegate instance may encapsulate either static or instance method."),(0,o.kt)("li",{parentName:"ul"},"Although the delegate can use an reference parameter (not const reference), we do not recommend its use with multicast event delegates because you cannot know which delegate will be called.")),(0,o.kt)("h3",{id:"example-1"},"Example 1"),(0,o.kt)("p",null,"TThe following is a simple example of declaring and using a delegate. Notice that both the delegate, ",(0,o.kt)("strong",{parentName:"p"},"del"),", and the associated method, ",(0,o.kt)("strong",{parentName:"p"},"multiply_numbers"),", have the same signature"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <xtd/xtd>\n\nusing namespace xtd;\n\n// Declare a delegate\nusing del = delegate<void(int i, double j)>;\n\nclass math_class {\npublic:\n  static auto main() {\n    math_class m;\n    \n    // Delegate instantiation using "MultiplyNumbers"\n    del d = {m, &math_class::multiply_numbers};\n    \n    // Invoke the delegate object.\n    console::write_line("Invoking the delegate using \'multiply_numbers\':");\n    for (int i = 1; i <= 5; i++) {\n      d(i, 2);\n    }\n    console::write_line();\n  }\n  \n  // Declare the associated method.\n  void multiply_numbers(int m, double n) {\n    console::write("{} ", m * n);\n  }\n};\n\nstartup_(math_class);\n\n/* Output:\n Invoking the delegate using \'multiply_numbers\':\n 2 4 6 8 10\n */\n')),(0,o.kt)("h3",{id:"example-2"},"Example 2"),(0,o.kt)("p",null,"In the following example, one delegate is mapped to both static and instance methods and returns specific information from each."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <xtd/xtd>\n\nusing namespace xtd;\n\nusing del = delegate<void()>;\n\nclass sample_class {\npublic:\n  void instance_method() {\n    console::write_line("A message from the instance method.");\n  }\n  \n  static void static_method() {\n    console::write_line("A message from the static method.");\n  }\n};\n\nclass test_sample_class {\npublic:\n  static auto main() {\n    sample_class sc;\n    \n    // Map the delegate to the instance method:\n    del d = {sc, &sample_class::instance_method};\n    d();\n    \n    // Map to the static method:\n    d = sample_class::static_method;\n    d();\n  }\n};\n\nstartup_(test_sample_class);\n\n/* Output:\n A message from the instance method.\n A message from the static method.\n */\n')),(0,o.kt)("h2",{id:"delegates-with-lambda-expressions"},"Delegates with Lambda expressions"),(0,o.kt)("p",null,"The ",(0,o.kt)("strong",{parentName:"p"},"[","]","(",")")," operator creates a ",(0,o.kt)("a",{parentName:"p",href:"https://en.cppreference.com/w/cpp/language/lambda"},"lambda expression")," that can be converted to a ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/gammasoft71/xtd/blob/master/src/xtd.core/include/xtd/delegate.h"},"xtd::delegate")," type:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"xtd::func<int, int, int> sum([] (int a, int b) { return a + b; });\nxtd::console::write_line(sum(3, 4));  // output: 7\n")),(0,o.kt)("p",null,"When you use the ",(0,o.kt)("strong",{parentName:"p"},"[","]","(",")")," operator, you might omit the parameter list. If you do that, the created anonymous method can be converted to a delegate type with any list of parameters, as the following example shows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},'xtd::action<> greet([] { xtd::console::write_line("Hello!"); });\ngreet();\n\nxtd::action<int, double> introduce([] { xtd::console::write_line("This is world!"); });\nintroduce(42, 2.7);\n\n// Output:\n// Hello!\n// This is world!\n')),(0,o.kt)("p",null,"This functionality of lambda expression is supported by ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/gammasoft71/xtd/blob/master/src/xtd.core/include/xtd/delegate.h"},"xtd::delegate")," but not by std::function."),(0,o.kt)("h2",{id:"see-also"},"See also"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"/docs/documentation/Guides/Overview/Tutorials"},"Tutorials")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"/docs/documentation"},"Documentation"))))}h.isMDXComponent=!0}}]);